replicaCount: 1
# avoiding cluster restart deadlock scenario 
# https://www.rabbitmq.com/docs/clustering#restarting-readiness-probes
podManagementPolicy: Parallel
auth:
  ## @param auth.username RabbitMQ application username
  ## ref: https://github.com/bitnami/containers/tree/main/bitnami/rabbitmq#environment-variables
  ##
  username: user
  ## @param auth.password RabbitMQ application password
  ## ref: https://github.com/bitnami/containers/tree/main/bitnami/rabbitmq#environment-variables
  ##
  password: ""
  ## @param auth.securePassword Whether to set the RabbitMQ password securely. This is incompatible with loading external RabbitMQ definitions and 'true' when not setting the auth.password parameter.
  ## ref: https://github.com/bitnami/containers/tree/main/bitnami/rabbitmq#environment-variables
  ##
  securePassword: true
  ## @param auth.existingPasswordSecret Existing secret with RabbitMQ credentials (existing secret must contain a value for `rabbitmq-password` key or override with setting auth.existingSecretPasswordKey)
  ## e.g:
  ## existingPasswordSecret: name-of-existing-secret
  ##
  existingPasswordSecret: "rabbitmq-admin-secret"
  ## @param auth.existingSecretPasswordKey [default: rabbitmq-password] Password key to be retrieved from existing secret
  ## NOTE: ignored unless `auth.existingSecret` parameter is set
  ##
  existingSecretPasswordKey: "password"
  ## @param auth.enableLoopbackUser If enabled, the user `auth.username` can only connect from localhost
  existingErlangSecret: "rabbitmq-admin-secret"
  ## @param auth.existingSecretErlangKey [default: rabbitmq-erlang-cookie] Erlang cookie key to be retrieved from existing secret
  ## NOTE: ignored unless `auth.existingErlangSecret` parameter is set
  ##
  existingSecretErlangKey: "erlang_cookie"
resources:
  requests:
    cpu: 12
    memory: 12Gi
  limits:
    cpu: 14
    memory: 16Gi
persistence:
  storageClass: longhorn
  storage: 8Gi

metrics:
    ## Metrics service parameters
    ##
    service:
      ## @param clusterOperator.metrics.service.enabled Create a service for accessing the metrics endpoint
      ##
      enabled: true
      ## @param clusterOperator.metrics.service.type RabbitMQ Cluster Operator metrics service type
      ##
      type: ClusterIP
      ## @param clusterOperator.metrics.service.ports.http RabbitMQ Cluster Operator metrics service HTTP port
      ##
      ports:
        http: 80 
      ## Node ports to expose
      ## @param clusterOperator.metrics.service.nodePorts.http Node port for HTTP
      ## NOTE: choose port between <30000-32767>
      ##
      nodePorts:
        http: ""
      ## @param clusterOperator.metrics.service.clusterIP RabbitMQ Cluster Operator metrics service Cluster IP
      ## e.g.:
      ## clusterIP: None
      ##
      clusterIP: ""
      ## @param clusterOperator.metrics.service.extraPorts Extra ports to expose (normally used with the `sidecar` value)
      ##
      extraPorts: []
      ## @param clusterOperator.metrics.service.loadBalancerIP RabbitMQ Cluster Operator metrics service Load Balancer IP
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer
      ##
      loadBalancerIP: ""
      ## @param clusterOperator.metrics.service.loadBalancerSourceRanges RabbitMQ Cluster Operator metrics service Load Balancer sources
      ## ref: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
      ## e.g:
      ## loadBalancerSourceRanges:
      ##   - 10.10.10.0/24
      ##
      loadBalancerSourceRanges: []
      ## @param clusterOperator.metrics.service.externalTrafficPolicy RabbitMQ Cluster Operator metrics service external traffic policy
      ## ref https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
      ##
      externalTrafficPolicy: Cluster
      ## @param clusterOperator.metrics.service.annotations [object] Additional custom annotations for RabbitMQ Cluster Operator metrics service
      ##
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "{{ .Values.clusterOperator.metrics.service.ports.http }}"
      ## @param clusterOperator.metrics.service.sessionAffinity Session Affinity for Kubernetes service, can be "None" or "ClientIP"
      ## If "ClientIP", consecutive client requests will be directed to the same Pod
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
      ##
      sessionAffinity: None
      ## @param clusterOperator.metrics.service.sessionAffinityConfig Additional settings for the sessionAffinity
      ## sessionAffinityConfig:
      ##   clientIP:
      ##     timeoutSeconds: 300
      ##
      sessionAffinityConfig: {}
    serviceMonitor:
      enabled: true
      namespace: "monitoring"
      jobLabel: app.kubernetes.io/name
      interval: 1s
      scrapeTimeout: 750ms
